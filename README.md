Introduction:
	In this project a representation of a Mandelbrot set was generated using a load balanced program using MPI and OpenMP. The Mandelbrot set is the set of numbers resulting from repeated iterations of the complex function:
	Zn+! = Zn2 + C with Z0 = 0
C = x0 +iy0 is part of the Mandelbrot set if |Z| converges. Z acts as a threshold, and N is the maximum number of iterations we do.The pixel color in the visualization represents the amount of iterations it needs to pass the Z threshold value, the more iterations the brighter the pixel color.. The Z value is broken into real and imaginary parts so that the program can function:
Zr = x2 - y2 + x0
Zi = 2xy + y0
	In the visualization, the x-axis represents the real portion of the input, and the y-axis represents the imaginary.
	A challenge of a task like this is that dividing the work evenly will result in a load imbalance. If even chunks of the set were given to each node, some would take much longer than others to finish, making the total time for the job increase. This can be illustrated with the visualization.
	For this example, it is assumed that 4 nodes would be doing the work. The visualization of the Mandelbrot set has been tinted with red and blue to make it more apparent what area is being worked on by what node. In this visual it is obvious that nodes 2 and 3 have much more white pixels than nodes 1 and 4, meaning would have to compute much more iterations would have to be computed on nodes 2 and 3 making their runtime much longer than nodes 1 and 4. This means that two of the nodes will be doing nothing while the other two nodes are still working through their allotted work. This inefficiency is the load imbalance. This load imbalance can be solved in a variety of ways, the one chosen for this project was to utilize a Master/Worker system and to use Dynamic Scheduling.

Implementation:
	The Master/Worker pattern is used for the nodes to make the other part, Dynamic Scheduling, easier to manage. The ‘Master’ node does not do any computations, but instead gives out work to the other ‘Worker’ nodes. The master gives each worker a chunk of work, in this case a set of rows for the workers. It then will wait for the workers to give a result back, in which case the Master will then give that worker more work, if the work is finished, then the master will give the worker a special value that will tell it that it no longer has work to give out. This process is Dynamic Scheduling. OpenMP easily allows for tasks to be given Dynamic Scheduling by using the ‘dynamic’ argument when using the compiler instruction for a  ‘for’ loop. For MPI however, the program must be written to give out and assign work, which was described above.

Results and Discussion:
The load imbalance can be seen by the blue bars in the Time (Imbalanced) and Time (Balanced) graph. Some nodes have very short runtimes while others completely dwarf them in comparison. The evidence that there is no longer a load imbalance is that after implementing this each node and thread should have approximately the same runtime. This is illustrated in the following graphs depicting the load balanced Master/Worker version’s node runtimes, and a comparison between the load imbalance and balanced version of the verison only using OpenMP. Once the Master/Worker was set up and the task used Dynamic Scheduling the runtimes of the thread and Worker nodes were then even.
As expected when more nodes run the program the runtime decreases, but eventually the amount of performance gain plateaus. The final output is a correct Mandelbrot set.

Conclusion:
To further improve the performance of the workers OpenMP is used to the work of the Worker split across 12 threads. Once the Master has told all of its Workers that there is no more work, it collects the work of each Worker and combines it into the final visualization of the Mandelbrot set. Each node has its own matrix, the workers populate their matrix with the values they get from doing their work, because the Master will not assign two workers the same region to work on each of the workers’ matrices can be reduced on the Master node to get a singular output matrix which is then saved as an image.
